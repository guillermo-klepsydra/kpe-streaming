/*****************************************************************************
*                           Klepsydra Streaming Modules
*              Copyright (C) 2020-2022  Klepsydra Technologies GmbH
*                            All Rights Reserved.
*
*  This file is subject to the terms and conditions defined in
*  file 'LICENSE.md', which is part of this source code package.
*
*  NOTICE:  All information contained herein is, and remains the property of Klepsydra
*  Technologies GmbH and its suppliers, if any. The intellectual and technical concepts
*  contained herein are proprietary to Klepsydra Technologies GmbH and its suppliers and
*  may be covered by Swiss and Foreign Patents, patents in process, and are protected by
*  trade secret or copyright law. Dissemination of this information or reproduction of
*  this material is strictly forbidden unless prior written permission is obtained from
*  Klepsydra Technologies GmbH.
*
*****************************************************************************/

#include <klepsydra/admin/check_license.h>
#include <klepsydra/streaming/event_loop_publish_subscribe_factory.h>

namespace kpsr {
namespace streaming {

EventLoopPublishSubscribeFactory::EventLoopPublishSubscribeFactory(
    kpsr::Container *container, StreamingConfigurationManager *streamingConfigurationManager)
    : _container(container)
    , _streamingConfigurationManager(streamingConfigurationManager)
    , _poolSize(_streamingConfigurationManager->getStreamingConfiguration().poolSize)
    , _eventLoops(_streamingConfigurationManager->getStreamingConfiguration().numberOfEventLoops)
{
    check_license();
    kpsr::Threadpool::getCriticalThreadPool(
        _streamingConfigurationManager->getStreamingConfiguration().numberOfEventLoops + 2);
    kpsr::Threadpool::getNonCriticalThreadPool(
        _streamingConfigurationManager->getStreamingConfiguration().nonCriticalThreadPoolSize);

    for (size_t i = 0; i < _eventLoops.size(); i++) {
        spdlog::debug("EventLoopPublishSubscribeFactory::EventLoopPublishSubscribeFactory. New "
                      "eventloop with name: {}",
                      i);
        std::vector<int> cpuCores = _streamingConfigurationManager->getThreadDistributionPolicy()
                                        ->eventLoopCoreMap[i];
        _eventLoops[i] = std::make_shared<FactoryEventLoopType>(
            _container,
            std::to_string((i)),
            kpsr::high_performance::EVENT_LOOP_START_TIMEOUT_MICROSEC,
            cpuCores);
    }
}

EventLoopPublishSubscribeFactory::~EventLoopPublishSubscribeFactory()
{
    _eventLoops.clear();
}

EventLoopPtr EventLoopPublishSubscribeFactory::getEventLoop(const std::string &eventLoopName)
{
    return _eventLoops[_streamingConfigurationManager->addStepToEventLoop(eventLoopName)];
}

void EventLoopPublishSubscribeFactory::start()
{
    if (spdlog::default_logger()->level() == spdlog::level::debug) {
        spdlog::debug(
            "kpsr::streaming::EventLoopPublishSubscribeFactory::start. autogenerated json file:");
        spdlog::debug("{}", _streamingConfigurationManager->exportJsonString());
    }

    for (kpsr::streaming::EventLoopPtr const &eventloopPtr : _eventLoops) {
        eventloopPtr->start();
    }
    spdlog::debug("kpsr::streaming::EventLoopPublishSubscribeFactory::start. Started!");
}

void EventLoopPublishSubscribeFactory::stop()
{
    for (EventLoopPtr const &eventloopPtr : _eventLoops) {
        eventloopPtr->stop();
    }
}

const std::vector<EventLoopPtr> EventLoopPublishSubscribeFactory::getEventLoops()
{
    return _eventLoops;
}

const StreamingConfigurationManager *
EventLoopPublishSubscribeFactory::getStreamingConfigurationManager()
{
    return _streamingConfigurationManager;
}

int EventLoopPublishSubscribeFactory::getPoolSize() const
{
    return _poolSize;
}
} // namespace streaming
} // namespace kpsr