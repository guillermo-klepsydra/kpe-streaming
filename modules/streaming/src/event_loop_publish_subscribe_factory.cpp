/*****************************************************************************
*                           Klepsydra Streaming Modules
*              Copyright (C) 2020-2022  Klepsydra Technologies GmbH
*                            All Rights Reserved.
*
*  This file is subject to the terms and conditions defined in
*  file 'LICENSE.md', which is part of this source code package.
*
*  NOTICE:  All information contained herein is, and remains the property of Klepsydra
*  Technologies GmbH and its suppliers, if any. The intellectual and technical concepts
*  contained herein are proprietary to Klepsydra Technologies GmbH and its suppliers and
*  may be covered by Swiss and Foreign Patents, patents in process, and are protected by
*  trade secret or copyright law. Dissemination of this information or reproduction of
*  this material is strictly forbidden unless prior written permission is obtained from
*  Klepsydra Technologies GmbH.
*
*****************************************************************************/

#include <klepsydra/admin/check_license.h>
#include <klepsydra/streaming/event_loop_publish_subscribe_factory.h>


namespace kpsr {
namespace streaming {

    EventLoopPublishSubscribeFactory::EventLoopPublishSubscribeFactory(kpsr::Container * container,
                                                                       StreamingPolicy * streamingPolicy,
                                                                       const std::string& name)
        : kpsr::Service(nullptr, name)
        , _container(container)
        , _streamingPolicy(streamingPolicy)
        , _poolSize(_streamingPolicy->getStreamingConfiguration().poolSize)
        , _eventLoops(_streamingPolicy->getStreamingConfiguration().numberOfEventLoops)
        {
            check_license();
            kpsr::Threadpool::getCriticalThreadPool(_streamingPolicy->getStreamingConfiguration().numberOfEventLoops + 2);
            kpsr::Threadpool::getNonCriticalThreadPool(_streamingPolicy->getStreamingConfiguration().nonCriticalThreadPoolSize);

            for(size_t i = 0; i < _eventLoops.size(); i++) {
                spdlog::debug("EventLoopPublishSubscribeFactory::EventLoopPublishSubscribeFactory. New eventloop with name: {}", i);
                std::vector<int> cpuCores = _streamingPolicy->getStreamingConfiguration().eventLoopCoreMap[i];
                _eventLoops[i] = std::make_shared<FactoryEventLoopType>(
                    _container,
                    std::to_string((i)),
                    kpsr::high_performance::EVENT_LOOP_START_TIMEOUT_MICROSEC,
                    cpuCores);
            }
        }

    EventLoopPublishSubscribeFactory::~EventLoopPublishSubscribeFactory() {
        _eventLoops.clear();
    }

    std::string EventLoopPublishSubscribeFactory::processStepName(const std::string stepName) const {
        std::string eventLoopName = stepName;
        findAndReplaceAll(eventLoopName, "/", "");
        return eventLoopName;
    }

    EventLoopPtr EventLoopPublishSubscribeFactory::getEventLoop(const std::string & eventLoopName) {
        return _eventLoops[_streamingPolicy->addStepToEventLoop(eventLoopName)];
    }


    void EventLoopPublishSubscribeFactory::start() {
        if (spdlog::default_logger()->level() == spdlog::level::debug) {
            auto streamingConfiguration = _streamingPolicy->getStreamingConfiguration();
            spdlog::debug("kpsr::streaming::EventLoopPublishSubscribeFactory::start. autogenerated json file:");
            spdlog::debug("{}", streamingConfiguration.exportJsonString());
        }

        for(kpsr::streaming::EventLoopPtr const& eventloopPtr : _eventLoops) {
            eventloopPtr->start();
        }
        spdlog::debug("kpsr::streaming::EventLoopPublishSubscribeFactory::start. Started!");
    }

    void EventLoopPublishSubscribeFactory::stop() {
        for(EventLoopPtr const& eventloopPtr : _eventLoops) {
            eventloopPtr->stop();
        }
    }

    const std::vector<EventLoopPtr> EventLoopPublishSubscribeFactory::getEventLoops() {
        return _eventLoops;
    }

    const StreamingPolicy * EventLoopPublishSubscribeFactory::getStreamingPolicy() {
        return _streamingPolicy;
    }
}
}
